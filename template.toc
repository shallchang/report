\contentsline {chapter}{\hbox to\@tempdima {\hfil }Abstract}{iii}
\contentsline {chapter}{\hbox to\@tempdima {\hfil }Acknowledgements}{iv}
\contentsline {chapter}{\hbox to\@tempdima {\hfil }Introduction}{v}
\contentsline {chapter}{\numberline {1}Lambda Calculus}{1}
\contentsline {section}{\numberline {1.1}$\lambda $-terms}{1}
\contentsline {section}{\numberline {1.2}Substitution}{2}
\contentsline {section}{\numberline {1.3}$\beta $-reduction}{3}
\contentsline {section}{\numberline {1.4}Head Normal Form}{4}
\contentsline {section}{\numberline {1.5}Reduction strategies}{4}
\contentsline {subsection}{\numberline {1.5.1}Call-by-Name Reduction}{5}
\contentsline {subsection}{\numberline {1.5.2}Normal Order Reduction}{6}
\contentsline {subsection}{\numberline {1.5.3}Call-by-Value Reduction}{7}
\contentsline {subsection}{\numberline {1.5.4}Head Reduction}{8}
\contentsline {subsection}{\numberline {1.5.5}Applicative Order Reduction}{9}
\contentsline {section}{\numberline {1.6}$\lambda $-calculus with Explicit Substitution and Garbage Collection}{10}
\contentsline {subsection}{\numberline {1.6.1}The explicit substitution calculi}{11}
\contentsline {subsection}{\numberline {1.6.2}Reduction in $\lambda $xgc-calculus}{12}
\contentsline {section}{\numberline {1.7}Normal $\beta $-reduction vs Explicit Substitution and garbage collection}{12}
\contentsline {subsection}{\numberline {1.7.1}$\xrightarrow [\beta ]{}$ vs $\xrightarrow [bx]{}$}{13}
\contentsline {subsection}{\numberline {1.7.2}$\xrightarrow [\beta ]{}$ vs $\xrightarrow [bx]{}$ vs $\xrightarrow [bxgc]{}$}{14}
\contentsline {chapter}{\numberline {2}The Curry type assignment system}{16}
\contentsline {section}{\numberline {2.1}The System $\lambda \rightarrow $-Curry}{16}
\contentsline {section}{\numberline {2.2}Properties of $\lambda \rightarrow $}{18}
\contentsline {section}{\numberline {2.3}The principal type property}{18}
\contentsline {section}{\numberline {2.4}Typing $\lambda $xgc-terms}{19}
\contentsline {chapter}{\numberline {3}A Purely-Functional Programming Language --- Haskell}{21}
\contentsline {section}{\numberline {3.1}Functional Programming}{21}
\contentsline {section}{\numberline {3.2}Haskell}{21}
\contentsline {subsection}{\numberline {3.2.1}Pattern Matching}{22}
\contentsline {subsection}{\numberline {3.2.2}Guards}{22}
\contentsline {subsection}{\numberline {3.2.3}Local Definition}{22}
\contentsline {subsection}{\numberline {3.2.4}Self-defined Types}{23}
\contentsline {section}{\numberline {3.3}Model the $\lambda $-calculus and the Curry Type Assignment System in Haskell}{23}
\contentsline {subsection}{\numberline {3.3.1}Data Types}{23}
\contentsline {subsection}{\numberline {3.3.2}Parser}{24}
\contentsline {subsection}{\numberline {3.3.3}Main mechanism}{25}
\contentsline {section}{\numberline {3.4}Issues and Weakness of Implementation in Haskell }{25}
\contentsline {chapter}{\numberline {4}The $\lambda $-calculus and Curry Type Assignment System Implementation in Java}{27}
\contentsline {section}{\numberline {4.1}Different operational order between Haskell and Java}{27}
\contentsline {section}{\numberline {4.2}$\lambda $-calculus Representation}{28}
\contentsline {subsection}{\numberline {4.2.1}$\lambda $-terms}{28}
\contentsline {subsection}{\numberline {4.2.2}Parser}{30}
\contentsline {section}{\numberline {4.3}Curry Type Assignment System Representation}{30}
\contentsline {subsection}{\numberline {4.3.1}Types}{30}
\contentsline {subsection}{\numberline {4.3.2}Type substitution}{31}
\contentsline {subsection}{\numberline {4.3.3}Other data types}{32}
\contentsline {subsection}{\numberline {4.3.4}Core type assignment mechanism implementation}{32}
\contentsline {section}{\numberline {4.4}Explicit substitution and garbage collection}{33}
\contentsline {section}{\numberline {4.5}Syntax}{34}
\contentsline {chapter}{\numberline {5}GUI development}{35}
\contentsline {section}{\numberline {5.1}Layout}{35}
\contentsline {section}{\numberline {5.2}Functionalities}{36}
\contentsline {subsection}{\numberline {5.2.1}`Normalize' tracer}{36}
\contentsline {subsection}{\numberline {5.2.2}`Trace' tracer}{37}
\contentsline {subsection}{\numberline {5.2.3}`Single-step' tracer}{37}
\contentsline {subsection}{\numberline {5.2.4}Deal with non-terminating terms by trace}{38}
\contentsline {subsection}{\numberline {5.2.5}Explicit Substitution}{39}
\contentsline {chapter}{\numberline {6}Haskell vs Java, Pros and Cons}{40}
\contentsline {section}{\numberline {6.1}Pros}{40}
\contentsline {subsection}{\numberline {6.1.1}Concise and elegant}{40}
\contentsline {section}{\numberline {6.2}Cons}{40}
\contentsline {chapter}{\numberline {7}Conclusion}{41}
\contentsline {chapter}{\numberline {A}Haskell Implementation--main algorithm}{43}
